<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle - Keyboard & Logic</title>
    <style>
        :root {
            --bg-color: #121213;
            --tile-border: #3a3a3c;
            --correct: #538d4e;
            --present: #b59f3b;
            --absent: #3a3a3c;
            --key-bg: #818384;
            --key-text: #ffffff;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            padding: 10px;
            height: 100vh;
            user-select: none; /* ãƒ†ã‚­ã‚¹ãƒˆé¸æŠé˜²æ­¢ */
        }

        h1 { margin: 10px 0; font-size: 2rem; }

        #status-badge {
            font-size: 0.8rem;
            padding: 5px 15px;
            border-radius: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .status-loading { background: #b59f3b; color: black; }
        .status-success { background: #538d4e; color: white; }
        .status-error { background: #ff4444; color: white; }

        /* ç›¤é¢ */
        #game-board {
            display: grid;
            grid-template-columns: repeat(5, 55px);
            grid-template-rows: repeat(6, 55px);
            gap: 5px;
            margin-bottom: 20px;
        }

        .tile {
            width: 100%;
            height: 100%;
            border: 2px solid var(--tile-border);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            box-sizing: border-box;
        }
        
        /* æ–‡å­—ãŒå…¥ã£ãŸã¨ãã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚¯ãƒ©ã‚¹ï¼ˆä»»æ„ï¼‰ */
        .tile[data-state='active'] {
            border-color: #565758;
        }

        /* åˆ¤å®šå¾Œã®è‰² */
        .correct { background-color: var(--correct); border-color: var(--correct); }
        .present { background-color: var(--present); border-color: var(--present); }
        .absent  { background-color: var(--absent); border-color: var(--absent); }

        /* ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ */
        #keyboard-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 500px;
            padding: 0 10px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 6px;
            width: 100%;
        }

        .key {
            flex: 1;
            height: 58px;
            background-color: var(--key-bg);
            color: var(--key-text);
            border-radius: 4px;
            border: none;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            text-transform: uppercase;
            touch-action: manipulation; /* ã‚¹ãƒãƒ›ã§ã®é…å»¶é˜²æ­¢ */
        }

        .key-wide {
            flex: 1.5;
            font-size: 0.9rem;
        }

        #message {
            margin-top: 15px;
            font-weight: bold;
            height: 1.5em;
            text-align: center;
            color: #d7dadc;
        }

        #reset-btn {
            background-color: transparent;
            border: 1px solid #565758;
            color: #d7dadc;
            padding: 5px 10px;
            margin-top: 10px;
            cursor: pointer;
            border-radius: 4px;
            display: none;
        }
        #reset-btn:hover { background-color: #3a3a3c; }

    </style>
</head>
<body>

    <h1>WORDLE</h1>
    
    <div id="status-badge" class="status-loading">Dictionary: Loading...</div>
    
    <div id="game-board"></div>
    
    <p id="message">è¾æ›¸ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™...</p>

    <div id="keyboard-container"></div>

    <button id="reset-btn" onclick="resetGame()">æ–°ã—ãå§‹ã‚ã‚‹</button>

    <script>
        // è¾æ›¸URL
        const DICTIONARY_URL = "https://cdn.jsdelivr.net/gh/tabatkins/wordle-list@main/words";
        
        let wordList = [];
        let secretWord = "";
        let currentRow = 0;
        let currentGuess = ""; // ç¾åœ¨å…¥åŠ›ä¸­ã®æ–‡å­—åˆ—
        let isGameOver = false;

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ç®¡ç† { "A": "correct", "B": "absent", ... }
        let keyStates = {};

        const statusEl = document.getElementById("status-badge");
        const msgEl = document.getElementById("message");
        const boardEl = document.getElementById("game-board");
        const keyboardEl = document.getElementById("keyboard-container");
        const resetBtnEl = document.getElementById("reset-btn");

        // --- åˆæœŸåŒ– ---
        async function initGame() {
            try {
                // ç›¤é¢ç”Ÿæˆ
                createBoard();
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ç”Ÿæˆ
                createKeyboard();

                const response = await fetch(DICTIONARY_URL);
                if (!response.ok) throw new Error("Fetch Failed");
                const text = await response.text();
                
                wordList = text.split(/\s+/)
                               .map(w => w.trim().toUpperCase())
                               .filter(w => w.length === 5);

                statusEl.textContent = `Loaded (${wordList.length} words)`;
                statusEl.className = "status-success";
                msgEl.textContent = "Start!";
                
                // ç‰©ç†ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒŠãƒ¼
                document.addEventListener("keydown", handlePhysicalKey);
                resetBtnEl.style.display = "inline-block";

                startNewRound();
            } catch (error) {
                console.error(error);
                statusEl.textContent = "Load Error";
                statusEl.className = "status-error";
                msgEl.textContent = "è¾æ›¸ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ";
            }
        }

        function startNewRound() {
            secretWord = wordList[Math.floor(Math.random() * wordList.length)];
            console.log("Secret:", secretWord); // Debug

            currentRow = 0;
            currentGuess = "";
            isGameOver = false;
            keyStates = {};

            // ç›¤é¢ãƒªã‚»ãƒƒãƒˆ
            const tiles = document.querySelectorAll(".tile");
            tiles.forEach(t => {
                t.textContent = "";
                t.className = "tile";
                delete t.dataset.state;
            });

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®è‰²ãƒªã‚»ãƒƒãƒˆ
            const keys = document.querySelectorAll(".key");
            keys.forEach(k => {
                k.className = k.classList.contains("key-wide") ? "key key-wide" : "key";
            });

            msgEl.textContent = "";
        }

        function resetGame() {
            if (!isGameOver && !confirm("ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
            startNewRound();
        }

        // --- UIç”Ÿæˆ ---
        function createBoard() {
            boardEl.innerHTML = "";
            for (let i = 0; i < 30; i++) {
                let tile = document.createElement("div");
                tile.className = "tile";
                tile.id = "tile-" + i;
                boardEl.appendChild(tile);
            }
        }

        function createKeyboard() {
            const rows = [
                "QWERTYUIOP",
                "ASDFGHJKL",
                "ZXCVBNM"
            ];

            keyboardEl.innerHTML = "";

            rows.forEach((rowStr, index) => {
                const rowDiv = document.createElement("div");
                rowDiv.className = "keyboard-row";

                // 2è¡Œç›®ã¯å·¦å³ã«å°‘ã—ã‚¹ãƒšãƒ¼ã‚µãƒ¼ã‚’å…¥ã‚Œã‚‹ï¼ˆæœ¬å®¶æº–æ‹ ï¼‰
                if (index === 1) {
                    // spacer logic could go here if needed
                }

                // 3è¡Œç›®ã®æœ€åˆã«ENTER
                if (index === 2) {
                    addKey(rowDiv, "ENTER", "key-wide");
                }

                for (let char of rowStr) {
                    addKey(rowDiv, char);
                }

                // 3è¡Œç›®ã®æœ€å¾Œã«BackSpace
                if (index === 2) {
                    addKey(rowDiv, "âŒ«", "key-wide", "BACKSPACE");
                }

                keyboardEl.appendChild(rowDiv);
            });
        }

        function addKey(container, label, className = "", actionValue = null) {
            const btn = document.createElement("button");
            btn.textContent = label;
            btn.className = "key " + className;
            btn.dataset.key = actionValue || label; // data-keyã«å®Ÿéš›ã®å‹•ä½œæ–‡å­—ã‚’ä¿å­˜
            
            // ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
            btn.addEventListener("click", () => handleInput(btn.dataset.key));
            
            container.appendChild(btn);
        }

        // --- å…¥åŠ›ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ---

        // ç‰©ç†ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å¯¾å¿œ
        function handlePhysicalKey(e) {
            if (isGameOver) return;

            const key = e.key.toUpperCase();
            if (key === "ENTER") {
                handleInput("ENTER");
            } else if (key === "BACKSPACE") {
                handleInput("BACKSPACE");
            } else if (/^[A-Z]$/.test(key)) {
                handleInput(key);
            }
        }

        // å…¥åŠ›å…±é€šå‡¦ç†
        function handleInput(key) {
            if (isGameOver) return;

            if (key === "ENTER") {
                submitGuess();
            } else if (key === "BACKSPACE") {
                if (currentGuess.length > 0) {
                    currentGuess = currentGuess.slice(0, -1);
                    updateCurrentRow();
                }
            } else {
                // æ–‡å­—å…¥åŠ› (5æ–‡å­—æœªæº€ãªã‚‰è¿½åŠ )
                if (currentGuess.length < 5) {
                    currentGuess += key;
                    updateCurrentRow();
                }
            }
        }

        // ç¾åœ¨å…¥åŠ›ä¸­ã®è¡Œã‚’è¡¨ç¤ºæ›´æ–°
        function updateCurrentRow() {
            const startIdx = currentRow * 5;
            for (let i = 0; i < 5; i++) {
                const tile = document.getElementById(`tile-${startIdx + i}`);
                const char = currentGuess[i] || "";
                tile.textContent = char;
                
                // å…¥åŠ›ä¸­ã¯æ ç·šã®è‰²ã‚’å¤‰ãˆã‚‹ç­‰ã®æ¼”å‡ºç”¨
                if (char) tile.dataset.state = "active";
                else delete tile.dataset.state;
            }
        }

        // --- åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ ---
        function submitGuess() {
            if (currentGuess.length !== 5) {
                showMessage("æ–‡å­—æ•°ãŒè¶³ã‚Šã¾ã›ã‚“");
                return;
            }
            if (!wordList.includes(currentGuess)) {
                showMessage("è¾æ›¸ã«ãªã„å˜èªã§ã™");
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«æºã‚‰ã™å‡¦ç†ã‚’å…¥ã‚Œã¦ã‚‚è‰¯ã„
                return;
            }

            // åˆ¤å®šé–‹å§‹
            const colors = checkWord(currentGuess, secretWord);
            
            // ç›¤é¢ã®è‰²å¡—ã‚Š
            const startIdx = currentRow * 5;
            for (let i = 0; i < 5; i++) {
                const tile = document.getElementById(`tile-${startIdx + i}`);
                tile.className = `tile ${colors[i]}`; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³CSSã‚’å…¥ã‚Œã‚‹ãªã‚‰ã“ã“ã§
            }

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®è‰²æ›´æ–°
            updateKeyboardColors(currentGuess, colors);

            // å‹æ•—åˆ¤å®š
            if (currentGuess === secretWord) {
                showMessage("ğŸ‰ Great!", true);
                isGameOver = true;
            } else {
                currentRow++;
                if (currentRow >= 6) {
                    showMessage(`æ­£è§£ã¯ ${secretWord}`, true);
                    isGameOver = true;
                } else {
                    currentGuess = ""; // æ¬¡ã®è¡Œã¸
                }
            }
        }

        function checkWord(guess, secret) {
            let colors = Array(5).fill("absent");
            let secretChars = secret.split("");
            let guessChars = guess.split("");

            // 1. Green Check
            for (let i = 0; i < 5; i++) {
                if (guessChars[i] === secretChars[i]) {
                    colors[i] = "correct";
                    secretChars[i] = null;
                    guessChars[i] = null;
                }
            }
            // 2. Yellow Check
            for (let i = 0; i < 5; i++) {
                if (guessChars[i] !== null) {
                    let idx = secretChars.indexOf(guessChars[i]);
                    if (idx !== -1) {
                        colors[i] = "present";
                        secretChars[idx] = null;
                    }
                }
            }
            return colors;
        }

        function updateKeyboardColors(guess, colors) {
            for (let i = 0; i < 5; i++) {
                const char = guess[i];
                const color = colors[i];
                const currentStatus = keyStates[char];

                // å„ªå…ˆé †ä½: correct(ç·‘) > present(é»„) > absent(ç°)
                // æ—¢ã«ç·‘ãªã‚‰æ›´æ–°ã—ãªã„ã€æ—¢ã«é»„è‰²ãªã‚‰ç·‘ä»¥å¤–ã§ã¯æ›´æ–°ã—ãªã„
                if (currentStatus === "correct") continue;
                if (currentStatus === "present" && color !== "correct") continue;

                keyStates[char] = color;
            }

            // DOMã«åæ˜ 
            const keys = document.querySelectorAll(".key");
            keys.forEach(keyEl => {
                const k = keyEl.dataset.key;
                if (keyStates[k]) {
                    // ã‚¯ãƒ©ã‚¹ã‚’ä¸Šæ›¸ã (ä¾‹: key correct)
                    // key-wideã®å ´åˆã¯ãã‚Œã‚’ç¶­æŒã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                    const baseClass = keyEl.classList.contains("key-wide") ? "key key-wide" : "key";
                    keyEl.className = `${baseClass} ${keyStates[k]}`;
                }
            });
        }

        function showMessage(text, persist = false) {
            msgEl.textContent = text;
            if (!persist) {
                setTimeout(() => {
                    if (msgEl.textContent === text) msgEl.textContent = "";
                }, 2000);
            }
        }

        initGame();
    </script>
</body>
</html>
